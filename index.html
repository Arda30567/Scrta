<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber-Voxel Architect v5.0 Ultra</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden; 
            font-family: 'Segoe UI', 'Courier New', monospace; 
            user-select: none;
        }
        #input_video { 
            position: absolute; 
            width: 100vw; 
            height: 100vh; 
            object-fit: cover; 
            transform: scaleX(-1); 
            z-index: 1; 
            opacity: 0.3; /* Video biraz daha silik, hologram öne çıksın */
            filter: grayscale(80%) contrast(1.2); /* Siberpunk havası için */
        }
        #three_canvas { 
            position: absolute; 
            top: 0; 
            left: 0; 
            z-index: 5; 
            pointer-events: none; 
        }
        #biometric_canvas { 
            position: absolute; 
            width: 100vw; 
            height: 100vh; 
            z-index: 10; 
            transform: scaleX(-1); 
            pointer-events: none; 
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
        }
        .hud-panel { 
            position: absolute; 
            top: 20px; 
            left: 20px; 
            color: #00f0ff; 
            font-weight: bold; 
            font-size: 14px;
            text-shadow: 0 0 10px #00f0ff; 
            border-left: 4px solid #00f0ff; 
            padding: 15px;
            background: linear-gradient(90deg, rgba(0,20,40,0.8) 0%, rgba(0,0,0,0) 100%);
            backdrop-filter: blur(5px);
        }
        .stat-row { margin-bottom: 5px; display: flex; align-items: center; }
        .stat-label { width: 80px; opacity: 0.8; font-size: 11px; letter-spacing: 1px; }
        .stat-val { color: #fff; font-size: 16px; }
        
        #palette {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 20px;
            border: 1px solid #00f0ff;
        }
        .color-opt {
            width: 40px; height: 40px; border-radius: 50%; border: 2px solid #fff;
            cursor: pointer; transition: transform 0.2s;
        }
        .color-opt.active { transform: scale(1.2); box-shadow: 0 0 15px currentColor; }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            line-height: 1.5;
        }
        
        .loading-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #000; z-index: 999;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            color: #00f0ff;
        }
    </style>
    
    <!-- Three.js ve Eklentileri için Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div class="loading-overlay" id="loader">
        <h1>SİSTEM BAŞLATILIYOR...</h1>
        <p>Holografik Arayüz Yükleniyor</p>
    </div>

    <div id="ui-layer">
        <div class="hud-panel">
            <div style="font-size: 18px; margin-bottom: 10px; border-bottom: 1px solid #00f0ff; padding-bottom: 5px;">MİMAR_OS v5.0</div>
            <div class="stat-row"><span class="stat-label">DURUM:</span> <span id="mode" class="stat-val">BEKLENİYOR</span></div>
            <div class="stat-row"><span class="stat-label">VOKSEL:</span> <span id="count" class="stat-val">0</span></div>
            <div class="stat-row"><span class="stat-label">FPS:</span> <span id="fps" class="stat-val">60</span></div>
            <div style="margin-top: 10px; font-size: 10px; color: #ff3333;" id="alert-msg"></div>
            <button id="save-btn" style="background:transparent; border:1px solid #00f0ff; color:#00f0ff; margin-top:5px; cursor:pointer; font-family:inherit;">KAYDET</button>
            <button id="clear-btn" style="background:transparent; border:1px solid #ff3333; color:#ff3333; margin-top:5px; cursor:pointer; font-family:inherit;">SIFIRLA</button>
        </div>

        <div id="palette">
            <div class="color-opt active" style="background-color: #00f0ff;" data-c="0x00f0ff"></div>
            <div class="color-opt" style="background-color: #ff0055;" data-c="0xff0055"></div>
            <div class="color-opt" style="background-color: #ffff00;" data-c="0xffff00"></div>
            <div class="color-opt" style="background-color: #00ff66;" data-c="0x00ff66"></div>
            <div class="color-opt" style="background-color: #ffffff;" data-c="0xffffff"></div>
        </div>

        <div id="instructions">
            SAĞ EL ÇİMDİK: İNŞA ET<br>
            SOL EL YUMRUK: DÜNYAYI ÇEVİR<br>
            İKİ EL AÇIK: RENK MENÜSÜ<br>
            İŞARET PARMAĞI: SİLME LAZERİ
        </div>
    </div>

    <video id="input_video" autoplay playsinline muted></video>
    <canvas id="three_canvas"></canvas>
    <canvas id="biometric_canvas"></canvas>

    <!-- MediaPipe Scriptleri (Global Scope) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- SES MOTORU (Synth) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            const now = audioCtx.currentTime;
            if (type === 'build') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'delete') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            } else if (type === 'ui') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            }
        }

        // --- ELEMENTLER ---
        const videoElement = document.getElementById('input_video');
        const bioCanvas = document.getElementById('biometric_canvas');
        const bioCtx = bioCanvas.getContext('2d');
        const modeEl = document.getElementById('mode');
        const countEl = document.getElementById('count');
        const fpsEl = document.getElementById('fps');
        const paletteEl = document.getElementById('palette');
        const loader = document.getElementById('loader');

        // --- THREE.JS KURULUMU ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 25;

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three_canvas'), antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;

        // --- POST PROCESSING (BLOOM) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.1;
        bloomPass.strength = 1.2; // Neon parlaklığı
        bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        // --- DÜNYA VE IŞIKLAR ---
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        // Izgara Tabanı (Grid)
        const gridHelper = new THREE.GridHelper(50, 50, 0x003344, 0x001122);
        worldGroup.add(gridHelper);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        // --- VOKSEL YÖNETİMİ ---
        const voxelSize = 1.0;
        const voxels = new Map(); // "x,y,z" -> Mesh
        let currentColor = 0x00f0ff;

        // Renk Seçimi
        document.querySelectorAll('.color-opt').forEach(opt => {
            opt.addEventListener('click', (e) => {
                document.querySelectorAll('.color-opt').forEach(el => el.classList.remove('active'));
                opt.classList.add('active');
                currentColor = parseInt(opt.dataset.c);
                playSound('ui');
            });
        });

        // --- PARÇACIK SİSTEMİ (PARTICLES) ---
        const particleGeo = new THREE.BufferGeometry();
        const particleCount = 200;
        const pPos = new Float32Array(particleCount * 3);
        const pVel = new Float32Array(particleCount * 3);
        const pLife = new Float32Array(particleCount);
        particleGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const particleMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.2, transparent: true, blending: THREE.AdditiveBlending
        });
        const particleSystem = new THREE.Points(particleGeo, particleMat);
        worldGroup.add(particleSystem);

        // Parçacıkları sıfırla
        for(let i=0; i<particleCount; i++) pLife[i] = 0;

        function spawnExplosion(x, y, z, color) {
            particleMat.color.setHex(color);
            for(let i=0; i<30; i++) { // Her patlama için 30 parçacık kullan
                // Boşta olan bir parçacık bul (basit döngüsel mantık yerine rastgele seçiyoruz şimdilik)
                const idx = Math.floor(Math.random() * particleCount);
                pPos[idx*3] = x; pPos[idx*3+1] = y; pPos[idx*3+2] = z;
                pVel[idx*3] = (Math.random()-0.5) * 0.5;
                pVel[idx*3+1] = (Math.random()-0.5) * 0.5;
                pVel[idx*3+2] = (Math.random()-0.5) * 0.5;
                pLife[idx] = 1.0; // Ömür
            }
        }

        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            for(let i=0; i<particleCount; i++) {
                if(pLife[i] > 0) {
                    positions[i*3] += pVel[i*3];
                    positions[i*3+1] += pVel[i*3+1];
                    positions[i*3+2] += pVel[i*3+2];
                    pLife[i] -= 0.05;
                    // Eğer öldüyse uzaya gönder
                    if(pLife[i] <= 0) positions[i*3+1] = 9999; 
                }
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        // --- GÖSTERGE VE İŞARETÇİLER (CURSORS) ---
        const cursorMesh = new THREE.Mesh(
            new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize),
            new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.5 })
        );
        worldGroup.add(cursorMesh);
        cursorMesh.visible = false;

        // Lazer işaretçi için
        const laserLine = new THREE.Line(
            new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]),
            new THREE.LineBasicMaterial({ color: 0xff0055, linewidth: 2 })
        );
        worldGroup.add(laserLine);
        laserLine.visible = false;

        // --- YARDIMCI FONKSİYONLAR ---
        function createVoxel(x, y, z, color) {
            const geo = new THREE.BoxGeometry(voxelSize*0.95, voxelSize*0.95, voxelSize*0.95);
            // Standart değil Physical Material kullanıyoruz ki Bloom ile parlasın
            const mat = new THREE.MeshPhysicalMaterial({ 
                color: color, 
                metalness: 0.2, 
                roughness: 0.1,
                transmission: 0.1, // Camımsı
                emissive: color,
                emissiveIntensity: 0.5
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            
            // Kenar çizgileri (Cyber estetik)
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true }));
            mesh.add(line);

            worldGroup.add(mesh);
            voxels.set(`${x},${y},${z}`, mesh);
            countEl.innerText = voxels.size;
            
            spawnExplosion(x, y, z, color);
            playSound('build');
        }

        function removeVoxel(key) {
            if (voxels.has(key)) {
                const mesh = voxels.get(key);
                spawnExplosion(mesh.position.x, mesh.position.y, mesh.position.z, 0xff3333);
                worldGroup.remove(mesh);
                // Bellek temizliği
                mesh.geometry.dispose();
                if(Array.isArray(mesh.material)) mesh.material.forEach(m=>m.dispose());
                else mesh.material.dispose();
                
                voxels.delete(key);
                countEl.innerText = voxels.size;
                playSound('delete');
            }
        }

        // --- EL TAKİBİ DEĞİŞKENLERİ ---
        let smoothedHands = { Left: [], Right: [] };
        
        // State Machine
        let isGrabbing = false;
        let grabStartPos = new THREE.Vector3();
        let groupStartPos = new THREE.Vector3();
        let groupStartRot = new THREE.Euler();
        let lastHandPos = new THREE.Vector3();

        let isBuilding = false;
        let lastBuildPos = "";

        let paletteOpen = false;
        let paletteTimer = 0;

        function getLandmarkPos(landmarks, index, depth = 20) {
            // Ekran koordinatlarını 3D dünya koordinatlarına çevir (Basit projeksiyon)
            // x: -1 to 1, y: -1 to 1
            const x = (0.5 - landmarks[index].x) * 30; // Scale faktörü
            const y = (0.5 - landmarks[index].y) * 20;
            // z için yaklaşık değer
            const z = -landmarks[index].z * 30; 
            return new THREE.Vector3(x, y, z);
        }

        function drawCyberHUD(ctx, width, height) {
            // Basit HUD süslemeleri
            ctx.strokeStyle = "rgba(0, 240, 255, 0.2)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(20, height - 20); ctx.lineTo(100, height - 20); ctx.lineTo(120, height - 5);
            ctx.stroke();
        }

        function drawHandSkeleton(ctx, landmarks, label, color) {
            const points = landmarks;
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = 2;
            
            // Bağlantılar
            const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[9,10],[10,11],[11,12],[13,14],[14,15],[15,16],[0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17],[0,5]];
            
            ctx.beginPath();
            connections.forEach(([i, j]) => {
                ctx.moveTo(points[i].x * w, points[i].y * h);
                ctx.lineTo(points[j].x * w, points[j].y * h);
            });
            ctx.stroke();

            // Eklemler
            points.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x * w, p.y * h, 3, 0, Math.PI*2);
                ctx.fill();
            });
        }

        // --- ANA MANTIK DÖNGÜSÜ ---
        function onResults(results) {
            bioCtx.clearRect(0, 0, bioCanvas.width, bioCanvas.height);
            drawCyberHUD(bioCtx, bioCanvas.width, bioCanvas.height);

            cursorMesh.visible = false;
            laserLine.visible = false;
            
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                isGrabbing = false;
                isBuilding = false;
                paletteOpen = false;
                paletteEl.style.opacity = 0;
                modeEl.innerText = "SİNYAL YOK";
                return;
            }

            let lHand = null, rHand = null;

            // Elleri tanı ve yumuşat
            results.multiHandedness.forEach((handRef, index) => {
                const rawLandmarks = results.multiHandLandmarks[index];
                const label = handRef.label;
                const targetArr = smoothedHands[label];

                // İlk kez veya smooth update
                if (targetArr.length === 0) {
                    rawLandmarks.forEach(l => targetArr.push({...l}));
                } else {
                    rawLandmarks.forEach((l, i) => {
                        targetArr[i].x += (l.x - targetArr[i].x) * 0.3; // Yumuşatma faktörü
                        targetArr[i].y += (l.y - targetArr[i].y) * 0.3;
                        targetArr[i].z += (l.z - targetArr[i].z) * 0.3;
                    });
                }

                if (label === 'Left') lHand = targetArr;
                if (label === 'Right') rHand = targetArr;

                drawHandSkeleton(bioCtx, targetArr, label, label === 'Right' ? '#00f0ff' : '#ff0055');
            });

            // GESTURE ALGILAMA
            
            // 1. PALET AÇMA (İki el açık, avuçlar karşıya)
            if (lHand && rHand) {
                const lOpen = lHand[8].y < lHand[5].y && lHand[12].y < lHand[9].y; // Basit açık el kontrolü
                const rOpen = rHand[8].y < rHand[5].y && rHand[12].y < rHand[9].y;
                
                if (lOpen && rOpen && Math.abs(lHand[0].x - rHand[0].x) < 0.3) {
                    paletteTimer++;
                    if (paletteTimer > 30) {
                        paletteOpen = true;
                        paletteEl.style.opacity = 1;
                        modeEl.innerText = "MOD: RENK SEÇİMİ";
                    }
                } else {
                    paletteTimer = 0;
                    if (paletteOpen) {
                        paletteOpen = false;
                        paletteEl.style.opacity = 0;
                    }
                }
            }

            if (paletteOpen) return; // Menü açıkken başka işlem yapma

            // 2. SOL EL: KAMERA/DÜNYA KONTROLÜ (Grab)
            if (lHand) {
                const isFist = lHand[8].y > lHand[5].y && lHand[12].y > lHand[9].y; // Parmaklar kapalı
                const handPos3D = getLandmarkPos(lHand, 9); // Avuç içi merkezi
                
                if (isFist) {
                    if (!isGrabbing) {
                        isGrabbing = true;
                        grabStartPos.copy(handPos3D);
                        groupStartPos.copy(worldGroup.position);
                        groupStartRot.copy(worldGroup.rotation);
                        lastHandPos.copy(handPos3D);
                        playSound('ui');
                    } else {
                        // Hareket
                        const delta = new THREE.Vector3().subVectors(handPos3D, lastHandPos);
                        worldGroup.position.add(delta);
                        
                        // Rotasyon (Hafif bir döndürme hissi için x/y farkını kullan)
                        worldGroup.rotation.y += (handPos3D.x - lastHandPos.x) * 0.5;
                        worldGroup.rotation.x -= (handPos3D.y - lastHandPos.y) * 0.5;
                        
                        lastHandPos.copy(handPos3D);
                        modeEl.innerText = "MOD: TAŞIMA & DÖNDÜRME";
                    }
                } else {
                    isGrabbing = false;
                }
            }

            // 3. SAĞ EL: İNŞA VE SİLME
            if (rHand) {
                const thumbTip = rHand[4];
                const indexTip = rHand[8];
                const midTip = rHand[12];
                
                // Pinch mesafesi
                const distPinch = Math.sqrt(Math.pow(thumbTip.x-indexTip.x,2) + Math.pow(thumbTip.y-indexTip.y,2));
                const isPinching = distPinch < 0.05;

                // Tabanca Hareketi (İşaret parmağı açık, orta parmak kapalı, başparmak açık)
                const isGun = indexTip.y < rHand[6].y && midTip.y > rHand[10].y; 

                // 3D İmleç Pozisyonu
                const pointerPos = getLandmarkPos(rHand, 8); // İşaret parmağı ucu
                // Dünya koordinatına çevir (World Group inverse matrix ile)
                const localPos = worldGroup.worldToLocal(pointerPos.clone());
                
                // Grid'e oturt (Snap)
                const gx = Math.round(localPos.x / voxelSize) * voxelSize;
                const gy = Math.round(localPos.y / voxelSize) * voxelSize;
                const gz = Math.round(localPos.z / voxelSize) * voxelSize;

                if (isGun) {
                    // SİLME MODU (Raycast mantığı gibi ama basitçe parmak ucundaki kutuyu siler)
                    modeEl.innerText = "MOD: SİLİCİ (LAZER)";
                    
                    // Lazer çiz
                    const handBase = getLandmarkPos(rHand, 5);
                    const laserEnd = worldGroup.localToWorld(new THREE.Vector3(gx, gy, gz));
                    laserLine.geometry.setFromPoints([handBase, laserEnd]);
                    laserLine.visible = true;

                    // Hedefteki kutuyu vurgula
                    cursorMesh.position.copy(laserEnd);
                    cursorMesh.material.color.setHex(0xff0000);
                    cursorMesh.visible = true;

                    // Eğer parmak ucu bir vokselin içindeyse (yaklaşık)
                    const key = `${gx},${gy},${gz}`;
                    if (isPinching) { // Tetik
                         removeVoxel(key);
                    }

                } else {
                    // İNŞA MODU
                    // İmleci Göster
                    cursorMesh.position.copy(worldGroup.localToWorld(new THREE.Vector3(gx, gy, gz)));
                    cursorMesh.material.color.setHex(0x00ff00);
                    cursorMesh.visible = true;
                    modeEl.innerText = "MOD: İNŞAAT";

                    if (isPinching) {
                        const key = `${gx},${gy},${gz}`;
                        if (!isBuilding && key !== lastBuildPos) {
                            if (!voxels.has(key)) {
                                createVoxel(gx, gy, gz, currentColor);
                            }
                            lastBuildPos = key;
                            isBuilding = true;
                        }
                    } else {
                        isBuilding = false;
                        lastBuildPos = "";
                    }
                }
            }
        }

        // --- MEDIAPIPE BAŞLATMA ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720
        });
        
        // Loader Animasyonu
        videoElement.addEventListener('loadeddata', () => {
             cameraUtils.start();
             setTimeout(() => {
                 loader.style.display = 'none';
                 // Başlangıç sesi
                 playSound('ui');
             }, 2000);
        });

        // --- ANA RENDER DÖNGÜSÜ ---
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            // FPS Sayacı (Basit)
            if (Math.random() < 0.1) fpsEl.innerText = Math.round(1/delta);

            updateParticles();

            // Sadece sahneyi değil, composer'ı render et (Bloom için)
            composer.render();
        }
        animate();

        // --- KAYDET / YÜKLE ---
        document.getElementById('save-btn').addEventListener('click', () => {
            const data = [];
            voxels.forEach((mesh, key) => {
                data.push({
                    pos: key, 
                    color: mesh.material.color.getHex()
                });
            });
            localStorage.setItem('voxelWorld', JSON.stringify(data));
            document.getElementById('alert-msg').innerText = "DÜNYA KAYDEDİLDİ!";
            setTimeout(() => document.getElementById('alert-msg').innerText = "", 2000);
            playSound('ui');
        });

        document.getElementById('clear-btn').addEventListener('click', () => {
            voxels.forEach(mesh => {
                worldGroup.remove(mesh);
                mesh.geometry.dispose();
            });
            voxels.clear();
            countEl.innerText = "0";
            playSound('delete');
        });

        // Başlangıçta yükle
        setTimeout(() => {
            const saved = localStorage.getItem('voxelWorld');
            if (saved) {
                const data = JSON.parse(saved);
                data.forEach(d => {
                    const [x,y,z] = d.pos.split(',').map(Number);
                    if (!voxels.has(d.pos)) createVoxel(x, y, z, d.color);
                });
                document.getElementById('alert-msg').innerText = "KAYITLI DÜNYA YÜKLENDİ";
            }
        }, 3000);

        // Pencere Boyutlandırma
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bioCanvas.width = window.innerWidth;
            bioCanvas.height = window.innerHeight;
        });
        
        bioCanvas.width = window.innerWidth;
        bioCanvas.height = window.innerHeight;

    </script>
</body>
</html>

